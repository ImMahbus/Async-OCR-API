# Overview

This project creates an __Async Optical Character Reader(OCR) API__ to extract characters from Images.


# Tech Stack 

    Flask 
    MongoDB Atlas
    RabbitMQ
    Docker 
    Tesseract

# Working 


 *  At any instant, user can give a **POST** or a **GET** request to the server. 
 * In a **POST** api call, a __b64string__  is passed as a json by the user.
 * For each **POST** api call, server generates a random __task_id__, and sends the __b64string__  along with __task_id__ to the [__RabbitMQ__](https://www.rabbitmq.com/) task_queue. The __task_id__ is returned to the user for future reference.
 * __RabbitMQ_Worker__ takes the payload from the task_queue, 
 run it through the [__Tesseract__](https://github.com/tesseract-ocr/tesseract), to extract the characters from the Image.
 * After extraction, this data is then saved onto the __MongoDB__ database with __task_id__ as an identifier.
 * In a **GET** api call, __task_id__ is passed by the user.
 * For each **GET** api call, database is queried against the __task_id__ and if the task is processed, recognized_text is returned otherwise a null value is returned, inherently showing that the task is still under queue.

 # Project Directory Overview

```bash

ASSIGNMENT:.
│   .dockerignore
│   docker-compose.yml  
│   README.md
│   requirements.txt
│
├───server
│   │   .dockerignore
│   │   app.py
│   │   dockerfile
│   │   get.sh
│   │   post.sh
│   │   requirements.txt
│   │
│   ├───databases
│   │       database.py
│   │
│   └───image_data
│       │   imgtostring.py
│       │   README.md
│       │   
│       ├───b64stringjson
│       │       phototest.json
│       │
│       └───test_images
│               phototest.tif
│
└───worker
    │   .dockerignore
    │   app.py
    │   dockerfile
    │   ocr_engine.py
    │   requirements.txt
    │
    └───databases
            database.py 


```

# Prerequisite 

* **Docker** - 
[Installation Procedure](https://docs.docker.com/engine/install/)
* **Docker Compose** -
[Installation Procedure](https://docs.docker.com/compose/install/)


# Running the servers


## Build Image 

```bash
docker-compose build
```
## Starting the servers

Before starting the server, make sure that all the necessary ports are exposed. 
* 5000 - For running the server
* 15672 - For rabbitMQ
* 5672 - For rabbitMQ 

All three container, which includes a __server__, __worker__, __rabbitMQ__ could be started with following bash command. 
```bash
docker-compose up
```


# API 

## POST

To make a __POST__ request, run this command after running all the components using docker compose

```bash
docker exec server chmod +x post.sh
docker exec server ./post.sh filename.json
```
Here _filename_ is the name of __b64string__, stored in the directory __ASSIGNMENT/server/image_data/b64stringjson__ 

For testing purpose, a test __b64string__ json with filename __phototest.json__ is already placed in the above directory 

For example, to extract character from phototest.json, this command should be given to the terminal 
```bash
docker exec server ./post.sh phototest.json
```
This will return a __task_id__, which could be used to check the status of character extraction process using a __GET__ request.

## GET

To make a __GET__ request, run this command after getting few __task_id__ by ___POST___ request

```bash
docker exec server chmod +x get.sh 
docker exec server ./get.sh task_id 
```
Here __task_id__ is the one, that got generated by __POST__ request

__task_id__ consist of 20 character

A demo command for a __GET__ api call is given bellow
```bash
docker exec server ./get.sh 3dHWyCR6MHkJacxyWQmq
```
A json will be returned after the __GET__ request, which contain status and recognized_text. 

For more intricate control over api calls, post.sh and get.sh could be edited as required.

[post.sh](server/post.sh) and [get.sh](server/get.sh) are placed inside ./server Directory. 


## NOTE :

While starting the server, rabbitmq_worker can throw an exception like this.
```bash
rabbitmq_worker  | Traceback (most recent call last):
rabbitmq_worker  |   File "app.py", line 9, in <module>
rabbitmq_worker  |     connection = pika.BlockingConnection(pika.ConnectionParameters(host='rabbitmq'))
rabbitmq_worker  |   File "/usr/local/lib/python3.8/dist-packages/pika/adapters/blocking_connection.py", line 360, in __init__
rabbitmq_worker  |     self._impl = self._create_connection(parameters, _impl_class)
rabbitmq_worker  |   File "/usr/local/lib/python3.8/dist-packages/pika/adapters/blocking_connection.py", line 451, in _create_connection  
rabbitmq_worker  |     raise self._reap_last_connection_workflow_error(error)
rabbitmq_worker  | pika.exceptions.AMQPConnectionError
```
This is happening due to wrong order of execution of three containers. Because the auto restart on this container is ON,  this will be automatically be removed after few seconds. 

# Generating b64string from Images


Read the [README](server/image_data/README.md) file placed in ./server/image_data directory.
